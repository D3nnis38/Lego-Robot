#pragma config(Sensor, S1,     touch1,         sensorEV3_Touch)
#pragma config(Sensor, S2,     touch2,         sensorEV3_Touch)
#pragma config(Sensor, S3,     gyro,           sensorEV3_Gyro)
#pragma config(Sensor, S4,     distance,       sensorEV3_Ultrasonic)
#pragma config(Motor,  motorB,          left,          tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorC,          right,         tmotorEV3_Large, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//!!Code automatically generated by 'ROBOTC' configuration wizard

/*void find_wall() //Hitta minsta avståndet med hjälp av array
{
int wall_distance[360];
bool search_for_wall = true;
//int degrees;
while(getGyroDegrees(S1) <= 360){
setMotorSpeed(left, 50);
setMotorSpeed(right, 0);
for(int i = 0; i < 360; i++){
wall_distance[i] = getUSDistance(S2);
}
}
int samllest_distance = wall_distance[0];
for(i = 0; i < 360; i++){
if(wall_distance[i] < smallest_distance){
smallest_distance = wall_distance[i];
}
}
while(search_for_wall == true){
setMotorSpeed(left, 50);
setMotorSpeed(right, 0);
if(getUSDistance(S2) == smallest_distance)
{
bool run = false;
}
}
}*/
bool find_wall() {

	float shortest_distance = 999999;
	float shortest_degree;
	while(getGyroDegrees(gyro) <= 360)
	{
		displayBigTextLine(0, "%d", getGyroDegrees(gyro));
		setMotorSpeed(left, 25);
		setMotorSpeed(right, -25);
		if(getUSDistance(distance) < shortest_distance) {
			shortest_degree = getGyroDegrees(gyro);
			shortest_distance = getUSDistance(distance);
		}

	}
	sleep(3000);

	repeatUntil(getGyroDegrees(gyro) == shortest_degree)
	{
		setMotorSpeed(left, -25);
		setMotorSpeed(right, 25);
	}

	setMotorSpeed(left, 0);
	setMotorSpeed(right, 0);
	return true;
}

void go_to_wall(){
	while(getTouchValue(touch1) == 0 && getTouchValue(touch2) == 0){
		setMotorSpeed(left, 75);
		setMotorSpeed(right, 75);
	}
	while(getUSDistance(distance) < 10){
		setMotorSpeed(left, -25);
		setMotorSpeed(right, -25);
	}

	/*if(getUSDistance(distance) > 25){
		while(getUSDistance(distance) >= 25){
			setMotorSpeed(left, 25);
			setMotorSpeed(right, 25);

			}
		}
		else{
		while(getUSDistance(distance) <= 25){
			setMotorSpeed(left, -25);
			setMotorSpeed(right, -25);
		}
	}
	setMotorSpeed(left, 25);
	setMotorSpeed(right, 25);*/
}

task main(){
	resetGyro(gyro);
	bool wall = false;

	wall = find_wall();
	resetGyro(gyro);
	if(wall == true){
		go_to_wall();

		while(getGyroDegrees(gyro) <= 90){
			setMotorSpeed(left, 25);
			setMotorSpeed(right, -25);
			displayBigTextLine(0, "%d", getGyroDegrees(gyro));
		}
		setMotorSpeed(left, 10);
		setMotorSpeed(right, 10);

	}
	else{
		displayBigStringAt(0, 16, "NO WALL FOUND!");
	}
}
