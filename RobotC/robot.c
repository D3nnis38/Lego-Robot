#pragma config(Sensor, S3,     gyro,           sensorEV3_Gyro)
#pragma config(Sensor, S4,     distance,       sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          arm,           tmotorEV3_Medium, PIDControl, encoder)
#pragma config(Motor,  motorB,          left,          tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorC,          right,         tmotorEV3_Large, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//!!Code automatically generated by 'ROBOTC' configuration wizard

/*void find_wall() //Hitta minsta avståndet med hjälp av array
{
	int wall_distance[360];
	bool search_for_wall = true;
	//int degrees;

	while(getGyroDegrees(S1) <= 360){
		setMotorSpeed(left, 50);
		setMotorSpeed(right, 0);

		for(int i = 0; i < 360; i++){
			wall_distance[i] = getUSDistance(S2);
		}
	}
	int samllest_distance = wall_distance[0];

	for(i = 0; i < 360; i++){
		if(wall_distance[i] < smallest_distance){
			smallest_distance = wall_distance[i];
		}
	}


	while(search_for_wall == true){
		setMotorSpeed(left, 50);
		setMotorSpeed(right, 0);
		if(getUSDistance(S2) == smallest_distance)
		{
			bool run = false;
		}
	}
}*/
bool find_wall() {

    float shortest_distance = 999999;
    float shortest_degree;
		resetGyro(gyro);
    while(getGyroDegrees(gyro) < 360)
    {
    		displayBigTextLine(0, "%d", getGyroDegrees(gyro));
        setMotorSpeed(left, 25);
        setMotorSpeed(right, -25);
        if(getUSDistance(distance) < shortest_distance) {
            shortest_degree = getGyroDegrees(gyro);
            shortest_distance = getUSDistance(distance);
        }

    }
    sleep(500);

    repeatUntil(getGyroDegrees(gyro) == shortest_degree)
    {
        setMotorSpeed(left, -25);
        setMotorSpeed(right, 25);
    }

    setMotorSpeed(left, 0);
    setMotorSpeed(right, 0);
    return true;
}

void go_to_wall(){
	if(getUSDistance(distance) > 25){
		while(getUSDistance(distance) >= 25){
				setMotorSpeed(left, 25);
				setMotorSpeed(right, 25);
		}
	}
	else{
		while(getUSDistance(distance) <= 25){
			setMotorSpeed(left, -25);
			setMotorSpeed(right, -25);
		}
	}
	setMotorSpeed(left, 0);
	setMotorSpeed(right, 0);
}

task main()
{
	bool wall = false;

	wall = find_wall();

	if(wall == true){
		go_to_wall();

		while(getGyroDegrees(gyro) <= 90){
			setMotorSpeed(left, -25);
			setMotorSpeed(right, 0);
			displayBigTextLine(0, "%d", getGyroDegrees(gyro));
		}
		setMotorSpeed(left, 0);
		setMotorSpeed(right, 0);
	}
	else{
		displayBigStringAt(0, 16, "NO WALL FOUND!");
	}

}
