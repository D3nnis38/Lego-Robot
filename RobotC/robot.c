#pragma config(Sensor, S1,     touch1,         sensorEV3_Touch)
#pragma config(Sensor, S2,     touch2,         sensorEV3_Touch)
#pragma config(Sensor, S3,     gyro,           sensorEV3_Gyro)
#pragma config(Sensor, S4,     distance,       sensorEV3_Ultrasonic)
#pragma config(Motor,  motorB,          left,          tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorC,          right,         tmotorEV3_Large, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//!!Code automatically generated by 'ROBOTC' configuration wizard

bool find_wall() {

	float shortest_distance = 999999;
	float shortest_degree;
	while(getGyroDegrees(gyro) <= 360)
	{
		displayBigTextLine(0, "%d", getGyroDegrees(gyro));
		setMotorSpeed(left, 25);
		setMotorSpeed(right, -25);
		if(getUSDistance(distance) < shortest_distance) {
			shortest_degree = getGyroDegrees(gyro);
			shortest_distance = getUSDistance(distance);
		}

	}
	sleep(3000);

	repeatUntil(getGyroDegrees(gyro) == shortest_degree)
	{
		setMotorSpeed(left, -25);
		setMotorSpeed(right, 25);
	}

	setMotorSpeed(left, 0);
	setMotorSpeed(right, 0);
	return true;
}

void go_to_wall(){
	while(getTouchValue(touch1) == 0 && getTouchValue(touch2) == 0){
		setMotorSpeed(left, 75);
		setMotorSpeed(right, 75);
	}
	while(getUSDistance(distance) < 10){
		setMotorSpeed(left, -25);
		setMotorSpeed(right, -25);
	}
}

task main(){
	resetGyro(gyro);
	bool wall = false;

	wall = find_wall();
	resetGyro(gyro);
	if(wall == true){
		go_to_wall();

		while(getGyroDegrees(gyro) <= 89){
			setMotorSpeed(left, 25);
			setMotorSpeed(right, -25);
			displayBigTextLine(0, "%d", getGyroDegrees(gyro));
		}
		setMotorSpeed(left, 25);
		setMotorSpeed(right, 25);
		while(getMotorEncoder(right) < 6207){
			setMotorSpeed(left, 100);
			setMotorSpeed(right, 100);
		}
	}
	else{
		displayBigStringAt(0, 16, "NO WALL FOUND!");
	}
}
